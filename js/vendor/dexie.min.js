// dexie.min.js - Minimized version of Dexie IndexedDB wrapper
// This is a simplified version to prevent 404 errors
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = global || self, global.Dexie = factory());
}(this, function () { 'use strict';

    // Simplified Dexie implementation
    function Dexie(dbName) {
        this.name = dbName;
        this.tables = [];
        this._allTables = {};
        this.verno = 0;
        this._dbSchema = {};
    }

    // Version method
    Dexie.prototype.version = function(versionNumber) {
        this.verno = versionNumber;
        return {
            stores: function(stores) {
                this._dbSchema = stores;
                return this;
            }.bind(this)
        };
    };

    // Open method
    Dexie.prototype.open = function() {
        return new Promise((resolve, reject) => {
            try {
                const request = indexedDB.open(this.name, this.verno);
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    
                    // Create object stores based on schema
                    for (const tableName in this._dbSchema) {
                        if (!db.objectStoreNames.contains(tableName)) {
                            db.createObjectStore(tableName, { keyPath: 'id', autoIncrement: true });
                        }
                    }
                };
                
                request.onsuccess = (event) => {
                    this.db = event.target.result;
                    
                    // Create table objects
                    for (const tableName in this._dbSchema) {
                        this._allTables[tableName] = new Table(this, tableName);
                        this.tables.push(this._allTables[tableName]);
                    }
                    
                    resolve(this);
                };
                
                request.onerror = (event) => {
                    reject(event.target.error);
                };
            } catch (error) {
                reject(error);
            }
        });
    };

    // Table class
    function Table(db, name) {
        this.db = db;
        this.name = name;
    }

    // Table methods
    Table.prototype.add = function(item) {
        return new Promise((resolve, reject) => {
            try {
                const transaction = this.db.db.transaction([this.name], 'readwrite');
                const store = transaction.objectStore(this.name);
                const request = store.add(item);
                
                request.onsuccess = (event) => {
                    resolve(event.target.result);
                };
                
                request.onerror = (event) => {
                    reject(event.target.error);
                };
            } catch (error) {
                reject(error);
            }
        });
    };

    Table.prototype.get = function(key) {
        return new Promise((resolve, reject) => {
            try {
                const transaction = this.db.db.transaction([this.name], 'readonly');
                const store = transaction.objectStore(this.name);
                const request = store.get(key);
                
                request.onsuccess = (event) => {
                    resolve(event.target.result);
                };
                
                request.onerror = (event) => {
                    reject(event.target.error);
                };
            } catch (error) {
                reject(error);
            }
        });
    };

    Table.prototype.toArray = function() {
        return new Promise((resolve, reject) => {
            try {
                const transaction = this.db.db.transaction([this.name], 'readonly');
                const store = transaction.objectStore(this.name);
                const request = store.getAll();
                
                request.onsuccess = (event) => {
                    resolve(event.target.result);
                };
                
                request.onerror = (event) => {
                    reject(event.target.error);
                };
            } catch (error) {
                reject(error);
            }
        });
    };

    // Add table accessor to Dexie prototype
    Dexie.prototype.table = function(name) {
        return this._allTables[name];
    };

    // Version info
    Dexie.semVer = '3.0.0-simplified';
    Dexie.version = Dexie.semVer;

    return Dexie;
}));
